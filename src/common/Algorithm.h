#ifndef ALGORITHM_H_
#define ALGORITHM_H_

#include <stdlib.h>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <fstream>
using namespace std;

// This enum defines what is the target platform of the OpenCL code generated by generator
class AlgorithmTargetDevice {
public:
  enum targetDevice {FPGA, GPU};
};

class AlgorithmTargetLanguage {
public:
  enum targetLanguage {CUDA, OpenCL};
};

class CircularNumberGenerator {
public:
	CircularNumberGenerator (int topBound);
 	~CircularNumberGenerator ();

  int next();

private:
	int topBound;
  int current;
};


class WorkItemSet {
public:
	WorkItemSet ();
	~WorkItemSet ();

  void setNumOfInstructions (int numOfInstructions);
  int getNumOfInstructions ();

  void setDependency (bool dependency);
  bool getDependency ();

  void setNumOfHomogenousWorkItems (int numOfHomogenousWorkItems);
  int getNumOfHomogenousWorkItems ();

  void setFormula (string formula);
  string getFormula ();

  void setVectorSize (int vectorSize);
  int getVectorSize ();

  void setUseLocalMem (bool useLocalMem);
  bool getUseLocalMem ();

  void setFops (int fops);
  int getFops ();

private:
	int numOfInstructions;
  bool dependency;
	int numOfHomogenousWorkItems;
	string formula;
  int vectorSize;
	bool useLocalMem;
  int fops;
};

class Algorithm {
public:
  // Constructor and Deconsructor almost does not anything, but just creation of the object,
  // or destruction of the function.
  Algorithm ();
  ~Algorithm();

  // Set target device to FPGA or GPU. Cannot be called twice.
	Algorithm& targetDeviceIs (int generatorTargetDevice);

  // Sets the target language which the core is going to be created.
  // right now it could be either OpenCL or CUDA
	Algorithm& targetLanguageIs (int generatorTargetLanguage);

  // Sets the number of compute units for the FPGA platforms.
  Algorithm& numComputeUnitsIs (int numcomputeUnits);

 	// Sets the number of simd work items in a single compute
  // unit for the FPGA platforms.
  Algorithm& numSIMDWorkITemsIs (int numSIMDWorkITems);

  // Set the required work group size im 3 dimensions
	Algorithm& reqdWorkGroupSizeIs (int x, int y, int z){}

  // Set the work group size for this algorithm
  Algorithm& workGroupSizeIs (int* workGroupSize);

  // It sets the general allocation share of memory for each
  // single work item,
	Algorithm& memAllocationPerWorkItemIs (int memAllocationPerWorkItem);

  // It sets the memory reuse factor. Basically it'll tell
  // how many times each block of global data should be
  // re-used by different threads. many algorithms may
  // access piece of global data multiple times. This variable
  // can reflect that behaviour.
	Algorithm& memReuseFactorIs (int memoryReuseFactor);

	// Set the kernel name
  Algorithm& NameIs (string kernelName);

	// Start definition of the kernel function headerB
  Algorithm& startKernelFunction ();

  // Version 2 of starting a kernel, which also has the
  // size of all involved dimensions.
	Algorithm& startKernelFunctionV2 ();

  // Version 3 of starting a kernel.
	Algorithm& startKernelFunctionV3 ();

  // Version Simple 1 of starting a kernel.
	Algorithm& startKernelFunctionSimpleV1 ();

  // this will terminate the kernel function initiation
	Algorithm& endKernelFunction ();

  // It just basically creates a for loop, the type of
  // dependency realizes the unrollment of loop into parallel version or not.
	Algorithm& createFor (int numberOfInstructions, bool dependency, int loopLength,
                        string formula, int vectorSize, bool useLocalMem,
                        int fops);

  // This will be called after sequential calls into createFor.
  // This will generata the body of the kernel.
	Algorithm& generateFors (bool onlyMeta);

	// Generates the body of a single for loop. This functions will
  // be called recursively, until it finishes.
  Algorithm& generateSingleFor (int loopIndex);

  // This is the second version of kernel generator. The previous
  // generator tries to calculate all indexes for each level of
  // for loop, in the kernel. After modeling the SGEMM matrix
  // multiplcation code, we've realized the first version
  // introduces significant overhead, which burns all valuable
  // floating point operations.
  // As a result, we have decided to use multi dimensional feature
  // of OpenCL to infer the index for accessing the memory and
  // performing operations. After manual analysis for the second
  // version of generator, this new version generates much less
  // overhead for calculating indexes.
	Algorithm& generateForsV2 (bool onlyMeta);

	// Generates the body of a single for loop for the second
  // version. This function will be called recursively, until,
  // it finishes.
  Algorithm& generateSingleForV2 (int loopIndex,
                                  vector<vector<string> >& indexingFormulas,
                                  vector<vector<string> >& indexingFormulasPrev);

  // This is the third generation of kernel generator. Basically it's
  // the same as the second generation, except we provide a different
  // memory access pattern, which tries to utilize memory coalescing
  // as much as possible. Most algorithms on GPU are using this feature
  // for better speed up. If our model does not utilize it, then it cannot
  // achieve as close performance as possible to it's real counterpart.
	Algorithm& generateForsV3 (bool onlyMeta);

	// Generates the body of a single for loop for the third
  // version. This function will be called recursively,until
  // it finishes.
  Algorithm& generateSingleForV3 (int loopIndex,
                                  vector<vector<string> >& indexingFormulas,
                                  vector<vector<string> >& indexingFormulasPrev);

  // This is the first simple generation of kernel generator. Basically it's
  // going to generate the simplest version, which omits the
  // involvement of the memory access. This tries to rule out
  // memory effect.
	Algorithm& generateForsSimpleV1 (bool onlyMeta);

	// Generates the body of a single for loop for the simple
  // version. This function will be called recursively,until
  // it finishes.
	Algorithm& generateSingleForSimpleV1 (int loopIndex,
                                  vector<vector<string> >& indexingFormulas,
                                  vector<vector<string> >& indexingFormulasPrev,
                                  vector<vector<string> >& indexingLocalMem);

  // Writes the created kernel into a file
  Algorithm& writeToFile (string fileName);

  // Print out the generated file on the standard output
  Algorithm& verboseKernel ();

  // Generate all meta informations related to the algorithm.
  // There information are going to be used while executing
  // kernels and also post-execution for calculation of
  // final performance.
  Algorithm& popMetas ();

  // generate all meta information of the algorithm, for the
  // second version of the algorithm.
  Algorithm& popMetasV2 ();

  // generate all meta information of the algorithm, for the
  // third version of the algorithm.
	Algorithm& popMetasV3 ();

  // generate all meta information of the algorithm, for the
  // third version of the algorithm.
  Algorithm& popMetasSimpleV1 ();

  long long getGInSize ();
  long long getGOutSize ();
	string getKernelLocation ();
	int* nextLocalWorkSize ();
  int* getGlobalWorkSize ();
	long long getTotalNumFlops ();
	string getKernelName ();
	int getWorkDim ();
  int getM ();
  int getN ();
  int getP ();
	bool getIsV2 ();

	int getAlgorithmTargetDevice ();
  int getAlgorithmTargetLanguage ();

  Algorithm& verbose();
private:

  int currentIndentation;
	int algorithmTargetDevice;
	int algorithmTargetLanguage;
  int numComputeUnits;
  int memAllocationPerWorkItem;
  int memoryReuseFactor;
	vector<WorkItemSet> forLoops;
  int numberOfNestedForLoops;
  string currentKernelName;
  bool onlyMeta;
  ostringstream oss;

  long long totalNumFlops;

  // Variables below only belong to the OpenCL version of the code
  int* globalWorkSize;
  int* localWorkSize;
  int currentLocalWorkSizeIndex;
  int workDim;
  int vectorSize;
  int M;
  int N;
  int P;
  string kernelLocation;
	bool isV2;


  // These are information about the size of GIn and GOut
  // that should be allocated on the device
  long long GInSize;
  long long GOutSize;

  void PERROR (string errorString);

  string getIndent ();
};
#endif
